<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <title>AIæ•°å­—ç”Ÿå‘½</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    /* CSSæ ·å¼ */
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto;background:#f1f1f1}
    .app-container {display: flex;height: 100%;}
    #sidebar {width: 280px;background: #2c3e50;color: white;padding: 20px 0;overflow-y: auto;flex-shrink: 0;transition: all 0.3s ease;}
    #sidebar.collapsed {width: 0;padding: 0;overflow: hidden;}
    .sidebar-header {padding: 0 20px 20px;border-bottom: 1px solid #34495e;margin-bottom: 20px;display: flex;justify-content: space-between;align-items: center;}
    .sidebar-header h1 {margin: 0;font-size: 20px;font-weight: 600;}
    .sidebar-toggle {background: none;border: none;color: white;cursor: pointer;font-size: 18px;padding: 5px;border-radius: 4px;transition: background 0.2s;}
    .sidebar-toggle:hover {background: rgba(255,255,255,0.1);}
    .character-list {padding: 0 10px;}
    .character-item {padding: 15px;margin: 8px 0;border-radius: 10px;cursor: pointer;transition: all 0.3s ease;border: 2px solid transparent;}
    .character-item:hover {background: #34495e;}
    .character-item.active {background: #3498db;border-color: #2980b9;}
    .character-name {font-weight: 600;margin-bottom: 5px;}
    .character-desc {font-size: 12px;opacity: 0.8;line-height: 1.4;}
    #main-content {flex: 1;display: flex;flex-direction: column;transition: all 0.3s ease;}
    #main-content.expanded {margin-left: 0;}
    #chat-header {background: white;padding: 15px 20px;border-bottom: 1px solid #ddd;box-shadow: 0 2px 4px rgba(0,0,0,0.1);}
    .current-character {display: flex;align-items: center;gap: 10px;}
    .character-avatar {width: 40px;height: 40px;border-radius: 50%;background: #3498db;display: flex;align-items: center;justify-content: center;font-weight: bold;color: white;}
    .character-info h2 {margin: 0;font-size: 18px;}
    .character-info .character-tag {font-size: 12px;color: #666;margin-top: 2px;}
    #chat{height:100%;display:flex;flex-direction:column}
    #messages{flex:1;overflow-y:auto;padding:10px 15px 80px}
    .msg{display:flex;margin:8px 0;align-items:flex-end}
    .msg.me{flex-direction:row-reverse}
    .bubble{max-width:65%;padding:10px 14px;border-radius:16px;font-size:16px;line-height:1.45;word-break:break-word}
    .msg.ai .bubble{background:#fff;color:#000;cursor:pointer}
    .msg.me .bubble{background:#95ec69;color:#000;cursor:pointer}
    .voice-time{font-size:12px;color:#666;margin-left:6px}
    .msg.me .voice-time{color:#555}
    #bottom{position:fixed;bottom:0;right:0;left:280px;background:#fff;border-top:1px solid #ddd;padding:8px 12px;display:flex;align-items:center;gap:8px;transition: all 0.3s ease;}
    #bottom.expanded {left: 0;}
    #txt{flex:1;padding:10px 14px;font-size:16px;border:1px solid #ccc;border-radius:20px}
    #send,#mic{width:44px;height:44px;border:none;border-radius:50%;font-size:20px;cursor:pointer;color:#fff}
    #send{background:#007bff}
    #mic{background:#28a745}
    #mic.rec{background:#dc3545;animation:pulse 1s infinite}
    .recording-indicator{display:none;color:#dc3545;font-size:14px;margin-left:8px}
    .recording-indicator.show{display:inline}
    .processing{opacity:.7;font-style:italic}
    .playing .bubble{box-shadow:0 0 0 2px #007bff}
    
    /* AIå£°éŸ³ç”ŸæˆåŠ è½½åœˆåœˆ */
    .tts-loading {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: #f8f9fa;
      border-radius: 16px;
      font-size: 14px;
      color: #666;
      margin-top: 8px;
    }
    
    .loading-spinner {
      width: 16px;
      height: 16px;
      border: 2px solid #e9ecef;
      border-top: 2px solid #007bff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:.5}}
    @media (max-width: 768px) {
      .app-container {flex-direction: column;}
      #sidebar {width: 100%;height: auto;max-height: 200px;}
      #sidebar.collapsed {width: 100%;height: 60px;padding: 10px 0;}
      #sidebar.collapsed .character-list {display: none;}
      #bottom {left: 0;}
      #bottom.expanded {left: 0;}
    }
  </style>
</head>
<body>
<div class="app-container">
  <div id="sidebar">
    <div class="sidebar-header">
      <h1>AIæ•°å­—äºº</h1>
      <div style="display: flex; align-items: center;">
        <div style="font-size: 12px; opacity: 0.8; margin-right: 10px;">é€‰æ‹©å¯¹è¯å¯¹è±¡</div>
        <button class="sidebar-toggle" id="sidebar-toggle" title="æ”¶èµ·/å±•å¼€è¾¹æ ">â—€</button>
      </div>
    </div>
    <div class="character-list">
      <div class="character-item active" data-character="yujiale">
        <div class="character-name">xxx</div>
        <div class="character-desc">18å²è½¯ä»¶å·¥ç¨‹å­¦ç”Ÿï¼ŒæŠ€æœ¯çˆ±å¥½è€…ï¼Œæ€§æ ¼ç›´æ¥åŠ¡å®</div>
      </div>
      <div class="character-item" data-character="hujianbo">
        <div class="character-name">èƒ¡å…ˆç”Ÿ</div>
        <div class="character-desc">å…³æ³¨ç»„ç»‡å‘å±•ã€ä¸“ä¸šå‘å±•ä¸ç¤¾ä¼šèµ°å‘çš„æ€è€ƒè€…</div>
      </div>
      <div class="character-item" data-character="zhangtongxue">
        <div class="character-name">å¼ åŒå­¦</div>
        <div class="character-desc">å¤šæ„å–„æ„Ÿï¼Œå¿ƒæ€ç»†è…»</div>
      </div>
    </div>
  </div>

  <div id="main-content">
    <div id="chat-header">
      <div class="current-character">
        <div class="character-avatar" id="current-avatar">ä¿</div>
        <div class="character-info">
          <h2 id="current-name">xxx</h2>
          <div class="character-tag" id="current-desc">18å²è½¯ä»¶å·¥ç¨‹å­¦ç”Ÿï¼ŒæŠ€æœ¯çˆ±å¥½è€…</div>
        </div>
      </div>
    </div>
    <div id="chat">
      <div id="messages"></div>
    </div>
  </div>
</div>

<div id="bottom">
  <input id="txt" type="text" placeholder="è¯´ç‚¹ä»€ä¹ˆâ€¦">
  <button id="mic" title="è¯­éŸ³è¾“å…¥">ğŸ¤</button>
  <span id="recordingIndicator" class="recording-indicator">â— å½•éŸ³ä¸­...</span>
  <button id="send" title="å‘é€">â¤</button>
</div>

<script>
  /* ---------- è§’è‰²é…ç½® ---------- */
  const characters = {
    yujiale: {
      name: "xxx",
      avatar: "x",
      description: "18å²è½¯ä»¶å·¥ç¨‹å­¦ç”Ÿï¼ŒæŠ€æœ¯çˆ±å¥½è€…"
    },
    hujianbo: {
      name: "èƒ¡å…ˆç”Ÿ", 
      avatar: "èƒ¡",
      description: "æˆç†Ÿç¨³é‡çš„æ€è€ƒè€…"
    },
    zhangtongxue: {
      name: "å¼ åŒå­¦",
      avatar: "å¼ ", 
      description: "å¤šæ„å–„æ„Ÿï¼Œå¿ƒæ€ç»†è…»çš„åŒå­¦"
    }
  };

  /* ---------- å…¨å±€å˜é‡ ---------- */
  let currentCharacter = 'yujiale';
  let sidebarCollapsed = false;
  const $ = q => document.querySelector(q);
  const messages = $('#messages');
  const API_BASE = 'https://xxx:8080';

  let processingMessage = null;
  const userRecordings = new Map();
  let currentlyPlayingAudio = null;

  /* ---------- è¾¹æ æ”¶èµ·/å±•å¼€åŠŸèƒ½ ---------- */
  function toggleSidebar() {
    sidebarCollapsed = !sidebarCollapsed;
    
    const sidebar = $('#sidebar');
    const mainContent = $('#main-content');
    const bottom = $('#bottom');
    const toggleButton = $('#sidebar-toggle');
    
    if (sidebarCollapsed) {
      sidebar.classList.add('collapsed');
      mainContent.classList.add('expanded');
      bottom.classList.add('expanded');
      toggleButton.innerHTML = 'â–¶';
      toggleButton.title = 'å±•å¼€è¾¹æ ';
    } else {
      sidebar.classList.remove('collapsed');
      mainContent.classList.remove('expanded');
      bottom.classList.remove('expanded');
      toggleButton.innerHTML = 'â—€';
      toggleButton.title = 'æ”¶èµ·è¾¹æ ';
    }
  }

  // åˆå§‹åŒ–è¾¹æ åˆ‡æ¢æŒ‰é’®
  $('#sidebar-toggle').addEventListener('click', toggleSidebar);

  /* ---------- è§’è‰²åˆ‡æ¢ ---------- */
  async function switchCharacter(characterId) {
    if (characters[characterId]) {
      try {
        // è°ƒç”¨åç«¯APIåˆ‡æ¢è§’è‰²
        const res = await fetch(`${API_BASE}/character/switch`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({character: characterId})
        });
        
        const result = await res.json();
        
        if (result.success) {
          currentCharacter = characterId;
          const character = characters[characterId];
          
          // æ›´æ–°UI
          document.querySelectorAll('.character-item').forEach(item => {
            item.classList.remove('active');
          });
          document.querySelector(`[data-character="${characterId}"]`).classList.add('active');
          
          $('#current-avatar').textContent = character.avatar;
          $('#current-name').textContent = character.name;
          $('#current-desc').textContent = character.description;
          
          // æ¸…ç©ºå½“å‰å¯¹è¯
          messages.innerHTML = '';
          
          // å‘é€æ¬¢è¿æ¶ˆæ¯
          const welcomeMsg = `å·²åˆ‡æ¢åˆ°${character.name}ï¼Œå¼€å§‹å¯¹è¯å§ï¼`;
          log(welcomeMsg, false);
          
          console.log(`åˆ‡æ¢åˆ°è§’è‰²: ${character.name}`);
        } else {
          console.error('åˆ‡æ¢è§’è‰²å¤±è´¥:', result.message);
          log(`åˆ‡æ¢è§’è‰²å¤±è´¥: ${result.message}`, false);
        }
      } catch (error) {
        console.error('åˆ‡æ¢è§’è‰²è¯·æ±‚å¤±è´¥:', error);
        log('åˆ‡æ¢è§’è‰²è¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥', false);
      }
    }
  }

  // åˆå§‹åŒ–è§’è‰²é€‰æ‹©äº‹ä»¶
  document.querySelectorAll('.character-item').forEach(item => {
    item.addEventListener('click', function() {
      const characterId = this.getAttribute('data-character');
      switchCharacter(characterId);
    });
  });

  /* ---------- å·¥å…·å‡½æ•° ---------- */
  const log = (txt, me = false, isProcessing = false) => {
    const div = document.createElement('div');
    div.className = 'msg ' + (me ? 'me' : 'ai') + (isProcessing ? ' processing' : '');
    div.innerHTML = `<div class="bubble">${txt}</div>`;
    messages.appendChild(div);
    div.scrollIntoView({behavior:'smooth'});
    return div;
  };

  const updateMessage = (el, html, isProcessing = false) => {
    el.classList.toggle('processing', isProcessing);
    el.querySelector('.bubble').innerHTML = html;
  };

  const fmtTime = sec => {
    const m = Math.floor(sec / 60).toString().padStart(2, '0');
    const s = Math.floor(sec % 60).toString().padStart(2, '0');
    return `${m}:${s}`;
  };

  const b64toBlob = (b64, type) => {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
    return new Blob([arr], {type});
  };

  /* ---------- éŸ³é¢‘æ§åˆ¶ ---------- */
  const stopAllAudioPlayback = () => {
    userRecordings.forEach((d, el) => {
      if (d.isPlaying) { d.audio.pause(); d.audio.currentTime = 0; d.isPlaying = false; }
    });
    document.querySelectorAll('.msg.ai').forEach(el => {
      if (el._audio && !el._audio.paused) {
        el._audio.pause(); el._audio.currentTime = 0; el.classList.remove('playing');
      }
    });
    currentlyPlayingAudio = null;
  };

  const toggleAudioPlayback = (msgEl) => {
    const data = userRecordings.get(msgEl);
    if (!data) return;
    const {audio} = data;
    if (audio.paused) {
      stopAllAudioPlayback();
      audio.play().then(() => {
        data.isPlaying = true; currentlyPlayingAudio = audio;
        msgEl.classList.add('playing');
        audio.onended = () => { data.isPlaying = false; msgEl.classList.remove('playing'); currentlyPlayingAudio = null; };
        audio.onerror = () => { data.isPlaying = false; msgEl.classList.remove('playing'); currentlyPlayingAudio = null; };
      });
    } else {
      audio.pause(); audio.currentTime = 0; data.isPlaying = false; msgEl.classList.remove('playing'); currentlyPlayingAudio = null;
    }
  };

  const setupAudioMessage = (msgEl, blob, duration) => {
    const url = URL.createObjectURL(blob);
    const audio = new Audio(url);
    userRecordings.set(msgEl, {audio, isPlaying: false});
    const bubble = msgEl.querySelector('.bubble');
    bubble.style.cursor = 'pointer';
    bubble.onclick = () => toggleAudioPlayback(msgEl);
  };

  /* ---------- å½•éŸ³ ---------- */
  let mediaRecorder = null, audioChunks = [], isRecording = false, recordingStream = null, recordingStartTime = 0;

  async function startRecording() {
    try {
      recordingStream = await navigator.mediaDevices.getUserMedia({
        audio: {sampleRate: 16000, channelCount: 1, echoCancellation: true, noiseSuppression: true}
      });
      audioChunks = [];
      mediaRecorder = new MediaRecorder(recordingStream, {mimeType: 'audio/webm;codecs=opus'});
      mediaRecorder.ondataavailable = e => { if (e.data.size) audioChunks.push(e.data); };
      mediaRecorder.onstop = async () => {
        const duration = (Date.now() - recordingStartTime) / 1000;
        recordingStream.getTracks().forEach(t => t.stop());
        if (!audioChunks.length) { if (processingMessage) { updateMessage(processingMessage, 'å½•éŸ³æ•°æ®ä¸ºç©º', true); setTimeout(() => processingMessage && processingMessage.remove(), 3000); } return; }
        const blob = new Blob(audioChunks, {type: 'audio/webm'});
        await processRecording(blob, duration);
      };
      mediaRecorder.start();
      isRecording = true; recordingStartTime = Date.now();
      $('#mic').classList.add('rec'); $('#recordingIndicator').classList.add('show');
      processingMessage = log('å½•éŸ³ä¸­...', true, true);
      setTimeout(() => { if (isRecording) stopRecording(); }, 60000);
    } catch (e) {
      console.error(e);
      let msg = 'æ— æ³•è®¿é—®éº¦å…‹é£: ' + (e.name === 'NotAllowedError' ? 'è¯·å…è®¸éº¦å…‹é£æƒé™' : e.name === 'NotFoundError' ? 'æœªæ‰¾åˆ°éº¦å…‹é£è®¾å¤‡' : e.message);
      log(msg, true);
    }
  }

  function stopRecording() {
    if (mediaRecorder && isRecording) { mediaRecorder.stop(); isRecording = false; $('#mic').classList.remove('rec'); $('#recordingIndicator').classList.remove('show'); }
  }

  async function processRecording(blob, duration) {
    try {
      if (processingMessage) updateMessage(processingMessage, 'è½¬æ–‡å­—ä¸­...', true);
      const formData = new FormData();
      formData.append('file', blob, 'recording.webm');
      const res = await fetch(`${API_BASE}/asr`, {method: 'POST', body: formData});
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const r = await res.json();
      if (r.text && r.text.trim()) {
        const text = r.text.trim();
        if (processingMessage) {
          const html = `<span class="text">${text}</span><span class="voice-time">${fmtTime(duration)}</span>`;
          updateMessage(processingMessage, html, false);
          setupAudioMessage(processingMessage, blob, duration);
          sendChat(text);
        }
      } else if (r.error) { throw new Error(r.error); } else { throw new Error('æœªèƒ½è¯†åˆ«åˆ°è¯­éŸ³å†…å®¹'); }
    } catch (e) {
      console.error(e);
      let msg = 'è¯­éŸ³è¯†åˆ«å¤±è´¥: ' + (e.message.includes('Failed to fetch') ? 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥åç«¯æœåŠ¡æ˜¯å¦è¿è¡Œ' : e.message);
      if (processingMessage) { updateMessage(processingMessage, msg, true); setTimeout(() => processingMessage && processingMessage.remove(), 5000); }
    } finally { processingMessage = null; }
  }

  /* ---------- äº¤äº’ ---------- */
  $('#mic').onclick = e => { e.preventDefault(); isRecording ? stopRecording() : startRecording(); return false; };
  $('#send').onclick = e => {
    e.preventDefault();
    const t = $('#txt').value.trim();
    if (!t) return;
    log(t, true); sendChat(t); $('#txt').value = ''; return false;
  };
  $('#txt').onkeyup = e => { if (e.key === 'Enter') { e.preventDefault(); $('#send').click(); } };

  /* ---------- ç½‘ç»œ ---------- */
  async function sendChat(text) {
    let thinking = log('æ€è€ƒä¸­...', false, true);
    try {
      const res = await fetch(`${API_BASE}/chat`, {
        method: 'POST', 
        headers: {'Content-Type': 'application/json'}, 
        body: JSON.stringify({text, character: currentCharacter})
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const r = await res.json();
      if (thinking.parentNode) thinking.remove();
      
      // ä¿æŒæµå¼è¾“å‡ºæ•ˆæœ
      await speakAndShowStreaming(r.reply || 'ï¼ˆç©ºå›å¤ï¼‰', false);
      
    } catch (e) {
      console.error(e);
      if (thinking.parentNode) thinking.remove();
      let msg = 'ç½‘ç»œé”™è¯¯: ' + (e.message.includes('Failed to fetch') ? 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥åç«¯æœåŠ¡æ˜¯å¦è¿è¡Œ' : e.message);
      log(msg, false);
    }
  }

  // ä¿æŒæµå¼è¾“å‡ºçš„å‡½æ•°
  async function speakAndShowStreaming(text, me) {
    const textEl = log('', false);
    const bubble = textEl.querySelector('.bubble');
    
    // æµå¼è¾“å‡ºæ–‡å­—
    let index = 0;
    const typeText = () => {
      if (index < text.length) {
        bubble.innerHTML = text.substring(0, index + 1);
        index++;
        setTimeout(typeText, 50); // æ§åˆ¶æ‰“å­—é€Ÿåº¦
      } else {
        // æ–‡å­—è¾“å‡ºå®Œæˆåå¼€å§‹TTS
        startTTS(text, textEl, bubble);
      }
    };
    
    typeText();
  }

  // å•ç‹¬çš„TTSå‡½æ•°
  async function startTTS(text, textEl, bubble) {
    // æ·»åŠ åŠ è½½çŠ¶æ€
    const loadingHtml = `<div class="tts-loading">
      <div class="loading-spinner"></div>
      <span>AIå£°éŸ³ç”Ÿæˆä¸­...</span>
    </div>`;
    bubble.innerHTML = text + loadingHtml;
    
    try {
      const res = await fetch(`${API_BASE}/tts`, {
        method: 'POST', 
        headers: {'Content-Type': 'application/json'}, 
        body: JSON.stringify({text, character: currentCharacter})
      });
      
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const r = await res.json();
      
      if (r.error) throw new Error(r.error);
      
      // ç§»é™¤åŠ è½½çŠ¶æ€ï¼Œæ·»åŠ éŸ³é¢‘
      const blob = b64toBlob(r.wav_base64, 'audio/wav');
      const url = URL.createObjectURL(blob);
      const audio = new Audio(url);
      textEl._audio = audio;
      
      audio.addEventListener('loadedmetadata', () => {
        const t = fmtTime(audio.duration);
        bubble.innerHTML = `${text}<span class="voice-time">${t}</span>`;
      });
      
      audio.addEventListener('error', () => {
        textEl.classList.remove('playing');
        currentlyPlayingAudio = null;
        textEl._audio = null;
        bubble.innerHTML = `${text}<span class="voice-time" style="color:#dc3545"> (æ’­æ”¾å¤±è´¥)</span>`;
      });
      
      bubble.onclick = () => {
        if (audio.paused) { 
          stopAllAudioPlayback(); 
          audio.currentTime = 0; 
          audio.play(); 
          textEl.classList.add('playing'); 
          currentlyPlayingAudio = audio; 
        } else { 
          audio.pause(); 
          audio.currentTime = 0; 
          textEl.classList.remove('playing'); 
          currentlyPlayingAudio = null; 
        }
      };
      
      // è‡ªåŠ¨æ’­æ”¾
      setTimeout(() => {
        stopAllAudioPlayback();
        audio.play().catch(() => {});
        textEl.classList.add('playing');
        currentlyPlayingAudio = audio;
      }, 300);
      
      audio.onended = () => {
        textEl.classList.remove('playing');
        currentlyPlayingAudio = null;
        textEl._audio = null;
      };
      
    } catch (e) {
      console.error(e);
      // å¦‚æœå‡ºé”™ï¼Œç§»é™¤åŠ è½½çŠ¶æ€ï¼Œæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
      bubble.innerHTML = `${text}<span class="voice-time" style="color:#dc3545"> (è¯­éŸ³ç”Ÿæˆå¤±è´¥)</span>`;
    }
  }

  /* ---------- è°ƒè¯•å‡½æ•° ---------- */
  async function debugCharacterSystem() {
    try {
      console.log('=== è§’è‰²ç³»ç»Ÿè°ƒè¯• ===');
      
      // æ£€æŸ¥å½“å‰è§’è‰²
      const currentRes = await fetch(`${API_BASE}/character/current`);
      const currentData = await currentRes.json();
      console.log('å½“å‰è§’è‰²:', currentData);
      
      // æ£€æŸ¥è§’è‰²åˆ—è¡¨
      const listRes = await fetch(`${API_BASE}/character/list`);
      const listData = await listRes.json();
      console.log('è§’è‰²åˆ—è¡¨:', listData);
      
      // æ£€æŸ¥æœåŠ¡çŠ¶æ€
      const healthRes = await fetch(`${API_BASE}/health`);
      const healthData = await healthRes.json();
      console.log('æœåŠ¡çŠ¶æ€:', healthData);
      
    } catch (error) {
      console.error('è°ƒè¯•å¤±è´¥:', error);
    }
  }

  /* ---------- åˆå§‹åŒ– ---------- */
  window.addEventListener('load', () => {
    if (!navigator.mediaDevices?.getUserMedia) { log('è­¦å‘Šï¼šæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒå½•éŸ³åŠŸèƒ½', true); $('#mic').disabled = true; $('#mic').style.background = '#6c757d'; }
    if (!window.MediaRecorder) { log('è­¦å‘Šï¼šæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒMediaRecorder API', true); $('#mic').disabled = true; $('#mic').style.background = '#6c757d'; }
    
    // è¿è¡Œè°ƒè¯•
    debugCharacterSystem();
    
    // åˆå§‹åŒ–é»˜è®¤è§’è‰²
    console.log('åˆå§‹åŒ–é»˜è®¤è§’è‰²: yujiale');
  });
  
  document.addEventListener('submit', e => e.preventDefault());
</script>
</body>
</html>